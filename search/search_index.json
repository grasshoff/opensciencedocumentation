{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"annotation/","text":"anNotes: a modern annotation object anNotes are annotation objects which display their content in relation to anchors of content in another pane. They can interact with other panes. An annotation is a python instance of a class which attributes can be set displayed by methods. anNote classes anNotes classes are split into functional methods without UI frontend functions and a show method that invokes the streamlit display. @dataclass class anNote : def __init__ ( self ): self . a = 3","title":"anNote"},{"location":"annotation/#annotes-a-modern-annotation-object","text":"anNotes are annotation objects which display their content in relation to anchors of content in another pane. They can interact with other panes. An annotation is a python instance of a class which attributes can be set displayed by methods.","title":"anNotes: a modern annotation object"},{"location":"annotation/#annote-classes","text":"anNotes classes are split into functional methods without UI frontend functions and a show method that invokes the streamlit display. @dataclass class anNote : def __init__ ( self ): self . a = 3","title":"anNote classes"},{"location":"code/","text":"Modules for Scholarium loaddBook () Import works Source code in Code/scholarium.py @st . cache ( allow_output_mutation = True ) def loaddBook (): ''' Import works ''' dfdBook = \"/Volumes/openrepo/sources/pdfRep.json\" reg = \"/Volumes/openrepo/sources/euler_reg.json\" return ( pd . read_json ( dfdBook ), pd . read_json ( reg )) Reader () Old version f\u00fcr display of book Source code in Code/scholarium.py def Reader (): ''' Old version f\u00fcr display of book ''' state = declareState ( 'pages' , { \"page\" : 18 , \"off\" : 0 , 'highlight' : \"euler\" , 'document' : \"Goldbach\" }) page = state [ 'page' ] off = state [ 'off' ] # st.sidebar.subheader(\"NEXT/BACK\") left_column , right_column = st . sidebar . beta_columns ([ 3 , 1 ]) with left_column : if st . button ( 'back' ): page = page - 1 with right_column : if st . button ( 'next' ): page = page + 1 #### euler collection db , reg = loaddBook () eexp2 = st . sidebar . beta_expander ( \"volume\" ) with eexp2 : # collection = st.selectbox(\"collection\", [\"eulerOO\"]) collection = \"eulerOO\" df , lbook = outdB ( db , collection ) lbook = list ( reg [ \"name\" ]) book = st . selectbox ( \"book\" , lbook , format_func = lambda x : eulvol ( x )) dictbook , regbook = makedictbook ( df , reg , book ) off = regbook [ \"off\" ] if not state [ \"document\" ] == book : page = regbook [ \"titelp\" ] # page = titlepage[book] state [ \"document\" ] = book ## Page exp1 = st . sidebar . beta_expander ( \"page\" ) with exp1 : exp2 = False page = st . select_slider ( label = \"\" , options = range ( 1 , dictbook [ \"npag\" ]), value = page , format_func = lambda x : \"page \" + str ( x - off )) cite1 = st . sidebar . beta_expander ( \"cite\" ) with cite1 : def truepage ( x ): return str ( x - off ) def euvol ( x ): return eulvol ( x ) st . write ( \"Euler Opera Omnia \" , euvol ( book ), \", p.\" , truepage ( page )) state [ 'page' ] = page state [ 'off' ] = off displaydBook ( dictbook , state [ 'page' ]) Sqltools for causa activeToken () Returns the token, the current sessionID is registered to. Returns str/None: token or None if not registered Source code in Code/sqltools.py def activeToken (): ''' Returns the token, the current sessionID is registered to. Returns ------- str/None: token or None if not registered ''' if loginState (): con = sqlite3 . connect ( 'registry/user.db' ) cursor = con . cursor () active_tokens = [ x for x in cursor . execute ( 'SELECT * FROM users' )] sessionID = _getSessionID () for token in active_tokens : if sessionID == token [ 1 ]: activetoken = token [ 0 ] return activetoken else : return None addRegToSceneList ( sceneList ) Adds Registry to the scene dictionary, if the current sessionID is not registered to a token. Parameters sceneDict: dictionary of scenes and associated scene functions type: dict Returns list: new scene dictionary Source code in Code/sqltools.py def addRegToSceneList ( sceneList ): ''' Adds Registry to the scene dictionary, if the current sessionID is not registered to a token. Parameters ---------- sceneDict: dictionary of scenes and associated scene functions type: dict Returns ------- list: new scene dictionary ''' if loginState (): return sceneList else : sceneList = [ 'Registry' ] + sceneList return sceneList addRegToScenes ( sceneDict ) Adds Registry to the scene dictionary, if the current sessionID is not registered to a token. Parameters sceneDict: dictionary of scenes and associated scene functions type: dict Returns list: new scene dictionary Source code in Code/sqltools.py def addRegToScenes ( sceneDict ): ''' Adds Registry to the scene dictionary, if the current sessionID is not registered to a token. Parameters ---------- sceneDict: dictionary of scenes and associated scene functions type: dict Returns ------- list: new scene dictionary ''' if loginState (): sceneDict [ 'Auswertung' ] = statScene return sceneDict else : sceneDict [ 'Registry' ] = regScene return sceneDict declareState ( table , defaultState , tokenlist = [ 'admin' ]) Returns a default State-Dictionary if the User is not logged in or hasn't saved a state yet. Returns the result of ther loadState function of a given table. Parameters table: table name that should be loaded from token.db type: str defaultState: default return if nothing is saved or user isn't logged in type: dict Returns dict: State-Dictionary Source code in Code/sqltools.py def declareState ( table , defaultState , tokenlist = [ 'admin' ]): ''' Returns a default State-Dictionary if the User is not logged in or hasn't saved a state yet. Returns the result of ther loadState function of a given table. Parameters ---------- table: table name that should be loaded from token.db type: str defaultState: default return if nothing is saved or user isn't logged in type: dict Returns ------- dict: State-Dictionary ''' if loginState () and table in getTables (): return loadState ( table ) elif loadAdmin ( table ) != []: return loadAdmin ( table ) else : return defaultState getTables ( token = '' ) Loads a list of all tables saved under a token Returns list: list of table names Source code in Code/sqltools.py def getTables ( token = '' ): ''' Loads a list of all tables saved under a token Returns ------- list: list of table names ''' if token == '' : token = activeToken () con = sqlite3 . connect ( './registry/' + token + '.db' ) cursor = con . cursor () cursor . execute ( \"SELECT name FROM sqlite_master WHERE type='table';\" ) flatten = itertools . chain . from_iterable all_tables = list ( flatten ( cursor . fetchall ())) return all_tables loadGlobalAnnot ( doc , page ) Load all information stored in a table saved under a token Parameters table: name of the table to be loaded type: str Returns list: list of dictionaries containing a row each Source code in Code/sqltools.py def loadGlobalAnnot ( doc , page ): ''' Load all information stored in a table saved under a token Parameters ---------- table: name of the table to be loaded type: str Returns ------- list: list of dictionaries containing a row each ''' con = sqlite3 . connect ( 'registry/Doc_' + doc + '.db' ) con . row_factory = sqlite3 . Row cursor = con . cursor () try : cursor . execute ( 'SELECT * FROM Page_' + page ) except : output = [] else : output = [ dict ( row ) for row in cursor . fetchall ()] con . close () return output loadState ( table ) Loads the last saved row of a table saved under a token Parameters table: name of the table to be loaded type: str Returns dict: dictionary, keys are table headers, values are row information Source code in Code/sqltools.py def loadState ( table ): ''' Loads the last saved row of a table saved under a token Parameters ---------- table: name of the table to be loaded type: str Returns ------- dict: dictionary, keys are table headers, values are row information ''' token = activeToken () con = sqlite3 . connect ( './registry/' + token + '.db' ) con . row_factory = sqlite3 . Row cursor = con . cursor () try : cursor . execute ( 'SELECT * FROM ' + table ) except : output = [] else : output = { k : _findType ( v ) for ( k , v ) in [ dict ( row ) for row in cursor . fetchall ()][ - 1 ] . items ()} con . close () return output loadTable ( table , token = '' ) Load all information stored in a table saved under a token Parameters table: name of the table to be loaded type: str Returns list: list of dictionaries containing a row each Source code in Code/sqltools.py def loadTable ( table , token = '' ): ''' Load all information stored in a table saved under a token Parameters ---------- table: name of the table to be loaded type: str Returns ------- list: list of dictionaries containing a row each ''' if token == '' : token = activeToken () con = sqlite3 . connect ( './registry/' + token + '.db' ) con . row_factory = sqlite3 . Row cursor = con . cursor () try : cursor . execute ( 'SELECT * FROM ' + table ) except : output = [] else : output = [ dict ( row ) for row in cursor . fetchall ()] con . close () return output loginState () Checks if the current session ID is registered to a token. Returns bool: True if User is registered, False if not Source code in Code/sqltools.py def loginState (): ''' Checks if the current session ID is registered to a token. Returns ------- bool: True if User is registered, False if not ''' con = sqlite3 . connect ( 'registry/user.db' ) cursor = con . cursor () active_ids = [ x [ 1 ] for x in cursor . execute ( 'SELECT * FROM users' )] con . close () if _getSessionID () in active_ids : return True else : return False saveGlobalAnnot ( doc , page , save_var ) Saves dictionary into a specified table in the database associated with the registered token. Creates the table on the first save. Table head is build from the save_var keys. Adds date and time stamps when savong data. Parameters table: name of the table data is to be saved in type: str save_var: Dictionary of variables to be saved type: dict overwrite: optional (default: True), overwrites table if True, append data if False type: bool Returns st.write: Source code in Code/sqltools.py def saveGlobalAnnot ( doc , page , save_var ): ''' Saves dictionary into a specified table in the database associated with the registered token. Creates the table on the first save. Table head is build from the save_var keys. Adds date and time stamps when savong data. Parameters ---------- table: name of the table data is to be saved in type: str save_var: Dictionary of variables to be saved type: dict overwrite: optional (default: True), overwrites table if True, append data if False type: bool Returns ------- st.write: ''' # create sql connection con = sqlite3 . connect ( 'registry/Doc_' + doc + '.db' ) cursor = con . cursor () # check if table exists, create if it doesn't cursor . execute ( \"SELECT count(name) FROM sqlite_master WHERE type='table' AND name='Page_\" + page + \"'\" ) if cursor . fetchone ()[ 0 ] == 1 : pass else : table_keys_start = '(date text, time text, token text,' table_keys_end = ')' table_keys_mid = '' for k in list ( save_var . keys ()): table_keys_mid = table_keys_mid + str ( k ) + ' text,' table_keys_mid = table_keys_mid [ 0 : - 1 ] table_keys = table_keys_start + table_keys_mid + table_keys_end cursor . execute ( \"CREATE TABLE Page_\" + page + \" \" + table_keys ) con . commit () # write date into table cursor . execute ( \"SELECT count(name) FROM sqlite_master WHERE type='table' AND name='Page_\" + page + \"'\" ) day = str ( datetime . date . today ()) time = str ( datetime . datetime . now () . time ()) token = activeToken () keylen = len ( list ( save_var . keys ())) vals = [ day , time , token ] + [ str ( x ) for x in list ( save_var . values ())] cursor . executemany ( 'INSERT INTO Page_' + page + ' VALUES ' + '(' + ',' . join ([ '?' ] * ( keylen + 3 )) + ')' , ( vals ,)) con . commit () con . close () saveState ( table , save_var , overwrite = True ) Saves dictionary into a specified table in the database associated with the registered token. Creates the table on the first save. Table head is build from the save_var keys. Adds date and time stamps when savong data. Parameters table: name of the table data is to be saved in type: str save_var: Dictionary of variables to be saved type: dict overwrite: optional (default: True), overwrites table if True, append data if False type: bool Returns st.write: Source code in Code/sqltools.py def saveState ( table , save_var , overwrite = True ): ''' Saves dictionary into a specified table in the database associated with the registered token. Creates the table on the first save. Table head is build from the save_var keys. Adds date and time stamps when savong data. Parameters ---------- table: name of the table data is to be saved in type: str save_var: Dictionary of variables to be saved type: dict overwrite: optional (default: True), overwrites table if True, append data if False type: bool Returns ------- st.write: ''' if loginState (): # get active token token = activeToken () else : token = 'admin' #delete time/day token save_var . pop ( 'date' , None ) save_var . pop ( 'time' , None ) # create sql connection con = sqlite3 . connect ( 'registry/' + token + '.db' ) cursor = con . cursor () # check if table exists, create if it doesn't cursor . execute ( \"SELECT count(name) FROM sqlite_master WHERE type='table' AND name='\" + table + \"'\" ) if cursor . fetchone ()[ 0 ] == 1 : pass else : table_keys_start = '(date text, time text,' table_keys_end = ')' table_keys_mid = '' for k in list ( save_var . keys ()): table_keys_mid = table_keys_mid + str ( k ) + ' blob,' table_keys_mid = table_keys_mid [ 0 : - 1 ] table_keys = table_keys_start + table_keys_mid + table_keys_end cursor . execute ( \"CREATE TABLE \" + table + \" \" + table_keys ) con . commit () # delete table if overwrite == True if overwrite == True : con . execute ( 'DELETE FROM ' + str ( table )) else : pass # write date into table cursor . execute ( \"SELECT count(name) FROM sqlite_master WHERE type='table' AND name='\" + table + \"'\" ) day = str ( datetime . date . today ()) time = str ( datetime . datetime . now () . time ()) keylen = len ( list ( save_var . keys ())) vals = [ day , time ] + [ str ( x ) for x in list ( save_var . values ())] cursor . executemany ( 'INSERT INTO ' + table + ' VALUES ' + '(' + ',' . join ([ '?' ] * ( keylen + 2 )) + ')' , ( vals ,)) con . commit () con . close () userAdmin ( tokenlist = [ 'admin' ]) Creates necessary folder structure for logging in and saving data (registry folder) Creates ./registry/tokens.yaml Creates .registry/user.db Updates user.db according to the token.yml Parameters tokenlist: of no token.yml exists, listelements define the first tokens in yaml and db type: list Source code in Code/sqltools.py def userAdmin ( tokenlist = [ 'admin' ]): ''' Creates necessary folder structure for logging in and saving data (registry folder) Creates ./registry/tokens.yaml Creates .registry/user.db Updates user.db according to the token.yml Parameters ---------- tokenlist: of no token.yml exists, listelements define the first tokens in yaml and db type: list ''' # create registry folder if os . path . isdir ( './registry' ): pass else : os . mkdir ( './registry' ) # creates token yaml file if os . path . isfile ( './registry/token.yml' ): pass else : with open ( './registry/token.yml' , 'w+' ) as y : yaml . dump ( tokenlist , y ) # setup SQL-connection con = sqlite3 . connect ( './registry/user.db' ) cursor = con . cursor () # create users table in sql database, update tokens cursor . execute ( \"SELECT count(name) FROM sqlite_master WHERE type='table' AND name='users'\" ) if cursor . fetchone ()[ 0 ] == 1 : with open ( './registry/token.yml' ) as tok : tokens = yaml . load ( tok , Loader = yaml . FullLoader ) active_tokens = [ x [ 0 ] for x in cursor . execute ( 'SELECT * FROM users' )] missing_tokens = [ x for x in tokens if x not in active_tokens ] for tok in missing_tokens : cursor . execute ( \"INSERT INTO users VALUES ('\" + tok + \"',' ')\" ) con . commit () else : cursor . execute ( \"CREATE TABLE users (token text, sessionID text)\" ) for token in tokenlist : cursor . execute ( \"INSERT INTO users VALUES ('\" + str ( token ) + \"',' ')\" ) con . commit () #close SQL connection con . close ()","title":"Code"},{"location":"code/#modules-for-scholarium","text":"","title":"Modules for Scholarium"},{"location":"code/#Code.scholarium.loaddBook","text":"Import works Source code in Code/scholarium.py @st . cache ( allow_output_mutation = True ) def loaddBook (): ''' Import works ''' dfdBook = \"/Volumes/openrepo/sources/pdfRep.json\" reg = \"/Volumes/openrepo/sources/euler_reg.json\" return ( pd . read_json ( dfdBook ), pd . read_json ( reg ))","title":"loaddBook()"},{"location":"code/#Code.scholarium.Reader","text":"Old version f\u00fcr display of book Source code in Code/scholarium.py def Reader (): ''' Old version f\u00fcr display of book ''' state = declareState ( 'pages' , { \"page\" : 18 , \"off\" : 0 , 'highlight' : \"euler\" , 'document' : \"Goldbach\" }) page = state [ 'page' ] off = state [ 'off' ] # st.sidebar.subheader(\"NEXT/BACK\") left_column , right_column = st . sidebar . beta_columns ([ 3 , 1 ]) with left_column : if st . button ( 'back' ): page = page - 1 with right_column : if st . button ( 'next' ): page = page + 1 #### euler collection db , reg = loaddBook () eexp2 = st . sidebar . beta_expander ( \"volume\" ) with eexp2 : # collection = st.selectbox(\"collection\", [\"eulerOO\"]) collection = \"eulerOO\" df , lbook = outdB ( db , collection ) lbook = list ( reg [ \"name\" ]) book = st . selectbox ( \"book\" , lbook , format_func = lambda x : eulvol ( x )) dictbook , regbook = makedictbook ( df , reg , book ) off = regbook [ \"off\" ] if not state [ \"document\" ] == book : page = regbook [ \"titelp\" ] # page = titlepage[book] state [ \"document\" ] = book ## Page exp1 = st . sidebar . beta_expander ( \"page\" ) with exp1 : exp2 = False page = st . select_slider ( label = \"\" , options = range ( 1 , dictbook [ \"npag\" ]), value = page , format_func = lambda x : \"page \" + str ( x - off )) cite1 = st . sidebar . beta_expander ( \"cite\" ) with cite1 : def truepage ( x ): return str ( x - off ) def euvol ( x ): return eulvol ( x ) st . write ( \"Euler Opera Omnia \" , euvol ( book ), \", p.\" , truepage ( page )) state [ 'page' ] = page state [ 'off' ] = off displaydBook ( dictbook , state [ 'page' ])","title":"Reader()"},{"location":"code/#sqltools-for-causa","text":"","title":"Sqltools for causa"},{"location":"code/#Code.sqltools.activeToken","text":"Returns the token, the current sessionID is registered to.","title":"activeToken()"},{"location":"code/#Code.sqltools.activeToken--returns","text":"str/None: token or None if not registered Source code in Code/sqltools.py def activeToken (): ''' Returns the token, the current sessionID is registered to. Returns ------- str/None: token or None if not registered ''' if loginState (): con = sqlite3 . connect ( 'registry/user.db' ) cursor = con . cursor () active_tokens = [ x for x in cursor . execute ( 'SELECT * FROM users' )] sessionID = _getSessionID () for token in active_tokens : if sessionID == token [ 1 ]: activetoken = token [ 0 ] return activetoken else : return None","title":"Returns"},{"location":"code/#Code.sqltools.addRegToSceneList","text":"Adds Registry to the scene dictionary, if the current sessionID is not registered to a token.","title":"addRegToSceneList()"},{"location":"code/#Code.sqltools.addRegToSceneList--parameters","text":"sceneDict: dictionary of scenes and associated scene functions type: dict","title":"Parameters"},{"location":"code/#Code.sqltools.addRegToSceneList--returns","text":"list: new scene dictionary Source code in Code/sqltools.py def addRegToSceneList ( sceneList ): ''' Adds Registry to the scene dictionary, if the current sessionID is not registered to a token. Parameters ---------- sceneDict: dictionary of scenes and associated scene functions type: dict Returns ------- list: new scene dictionary ''' if loginState (): return sceneList else : sceneList = [ 'Registry' ] + sceneList return sceneList","title":"Returns"},{"location":"code/#Code.sqltools.addRegToScenes","text":"Adds Registry to the scene dictionary, if the current sessionID is not registered to a token.","title":"addRegToScenes()"},{"location":"code/#Code.sqltools.addRegToScenes--parameters","text":"sceneDict: dictionary of scenes and associated scene functions type: dict","title":"Parameters"},{"location":"code/#Code.sqltools.addRegToScenes--returns","text":"list: new scene dictionary Source code in Code/sqltools.py def addRegToScenes ( sceneDict ): ''' Adds Registry to the scene dictionary, if the current sessionID is not registered to a token. Parameters ---------- sceneDict: dictionary of scenes and associated scene functions type: dict Returns ------- list: new scene dictionary ''' if loginState (): sceneDict [ 'Auswertung' ] = statScene return sceneDict else : sceneDict [ 'Registry' ] = regScene return sceneDict","title":"Returns"},{"location":"code/#Code.sqltools.declareState","text":"Returns a default State-Dictionary if the User is not logged in or hasn't saved a state yet. Returns the result of ther loadState function of a given table.","title":"declareState()"},{"location":"code/#Code.sqltools.declareState--parameters","text":"table: table name that should be loaded from token.db type: str defaultState: default return if nothing is saved or user isn't logged in type: dict","title":"Parameters"},{"location":"code/#Code.sqltools.declareState--returns","text":"dict: State-Dictionary Source code in Code/sqltools.py def declareState ( table , defaultState , tokenlist = [ 'admin' ]): ''' Returns a default State-Dictionary if the User is not logged in or hasn't saved a state yet. Returns the result of ther loadState function of a given table. Parameters ---------- table: table name that should be loaded from token.db type: str defaultState: default return if nothing is saved or user isn't logged in type: dict Returns ------- dict: State-Dictionary ''' if loginState () and table in getTables (): return loadState ( table ) elif loadAdmin ( table ) != []: return loadAdmin ( table ) else : return defaultState","title":"Returns"},{"location":"code/#Code.sqltools.getTables","text":"Loads a list of all tables saved under a token","title":"getTables()"},{"location":"code/#Code.sqltools.getTables--returns","text":"list: list of table names Source code in Code/sqltools.py def getTables ( token = '' ): ''' Loads a list of all tables saved under a token Returns ------- list: list of table names ''' if token == '' : token = activeToken () con = sqlite3 . connect ( './registry/' + token + '.db' ) cursor = con . cursor () cursor . execute ( \"SELECT name FROM sqlite_master WHERE type='table';\" ) flatten = itertools . chain . from_iterable all_tables = list ( flatten ( cursor . fetchall ())) return all_tables","title":"Returns"},{"location":"code/#Code.sqltools.loadGlobalAnnot","text":"Load all information stored in a table saved under a token","title":"loadGlobalAnnot()"},{"location":"code/#Code.sqltools.loadGlobalAnnot--parameters","text":"table: name of the table to be loaded type: str","title":"Parameters"},{"location":"code/#Code.sqltools.loadGlobalAnnot--returns","text":"list: list of dictionaries containing a row each Source code in Code/sqltools.py def loadGlobalAnnot ( doc , page ): ''' Load all information stored in a table saved under a token Parameters ---------- table: name of the table to be loaded type: str Returns ------- list: list of dictionaries containing a row each ''' con = sqlite3 . connect ( 'registry/Doc_' + doc + '.db' ) con . row_factory = sqlite3 . Row cursor = con . cursor () try : cursor . execute ( 'SELECT * FROM Page_' + page ) except : output = [] else : output = [ dict ( row ) for row in cursor . fetchall ()] con . close () return output","title":"Returns"},{"location":"code/#Code.sqltools.loadState","text":"Loads the last saved row of a table saved under a token","title":"loadState()"},{"location":"code/#Code.sqltools.loadState--parameters","text":"table: name of the table to be loaded type: str","title":"Parameters"},{"location":"code/#Code.sqltools.loadState--returns","text":"dict: dictionary, keys are table headers, values are row information Source code in Code/sqltools.py def loadState ( table ): ''' Loads the last saved row of a table saved under a token Parameters ---------- table: name of the table to be loaded type: str Returns ------- dict: dictionary, keys are table headers, values are row information ''' token = activeToken () con = sqlite3 . connect ( './registry/' + token + '.db' ) con . row_factory = sqlite3 . Row cursor = con . cursor () try : cursor . execute ( 'SELECT * FROM ' + table ) except : output = [] else : output = { k : _findType ( v ) for ( k , v ) in [ dict ( row ) for row in cursor . fetchall ()][ - 1 ] . items ()} con . close () return output","title":"Returns"},{"location":"code/#Code.sqltools.loadTable","text":"Load all information stored in a table saved under a token","title":"loadTable()"},{"location":"code/#Code.sqltools.loadTable--parameters","text":"table: name of the table to be loaded type: str","title":"Parameters"},{"location":"code/#Code.sqltools.loadTable--returns","text":"list: list of dictionaries containing a row each Source code in Code/sqltools.py def loadTable ( table , token = '' ): ''' Load all information stored in a table saved under a token Parameters ---------- table: name of the table to be loaded type: str Returns ------- list: list of dictionaries containing a row each ''' if token == '' : token = activeToken () con = sqlite3 . connect ( './registry/' + token + '.db' ) con . row_factory = sqlite3 . Row cursor = con . cursor () try : cursor . execute ( 'SELECT * FROM ' + table ) except : output = [] else : output = [ dict ( row ) for row in cursor . fetchall ()] con . close () return output","title":"Returns"},{"location":"code/#Code.sqltools.loginState","text":"Checks if the current session ID is registered to a token.","title":"loginState()"},{"location":"code/#Code.sqltools.loginState--returns","text":"bool: True if User is registered, False if not Source code in Code/sqltools.py def loginState (): ''' Checks if the current session ID is registered to a token. Returns ------- bool: True if User is registered, False if not ''' con = sqlite3 . connect ( 'registry/user.db' ) cursor = con . cursor () active_ids = [ x [ 1 ] for x in cursor . execute ( 'SELECT * FROM users' )] con . close () if _getSessionID () in active_ids : return True else : return False","title":"Returns"},{"location":"code/#Code.sqltools.saveGlobalAnnot","text":"Saves dictionary into a specified table in the database associated with the registered token. Creates the table on the first save. Table head is build from the save_var keys. Adds date and time stamps when savong data.","title":"saveGlobalAnnot()"},{"location":"code/#Code.sqltools.saveGlobalAnnot--parameters","text":"table: name of the table data is to be saved in type: str save_var: Dictionary of variables to be saved type: dict overwrite: optional (default: True), overwrites table if True, append data if False type: bool","title":"Parameters"},{"location":"code/#Code.sqltools.saveGlobalAnnot--returns","text":"st.write: Source code in Code/sqltools.py def saveGlobalAnnot ( doc , page , save_var ): ''' Saves dictionary into a specified table in the database associated with the registered token. Creates the table on the first save. Table head is build from the save_var keys. Adds date and time stamps when savong data. Parameters ---------- table: name of the table data is to be saved in type: str save_var: Dictionary of variables to be saved type: dict overwrite: optional (default: True), overwrites table if True, append data if False type: bool Returns ------- st.write: ''' # create sql connection con = sqlite3 . connect ( 'registry/Doc_' + doc + '.db' ) cursor = con . cursor () # check if table exists, create if it doesn't cursor . execute ( \"SELECT count(name) FROM sqlite_master WHERE type='table' AND name='Page_\" + page + \"'\" ) if cursor . fetchone ()[ 0 ] == 1 : pass else : table_keys_start = '(date text, time text, token text,' table_keys_end = ')' table_keys_mid = '' for k in list ( save_var . keys ()): table_keys_mid = table_keys_mid + str ( k ) + ' text,' table_keys_mid = table_keys_mid [ 0 : - 1 ] table_keys = table_keys_start + table_keys_mid + table_keys_end cursor . execute ( \"CREATE TABLE Page_\" + page + \" \" + table_keys ) con . commit () # write date into table cursor . execute ( \"SELECT count(name) FROM sqlite_master WHERE type='table' AND name='Page_\" + page + \"'\" ) day = str ( datetime . date . today ()) time = str ( datetime . datetime . now () . time ()) token = activeToken () keylen = len ( list ( save_var . keys ())) vals = [ day , time , token ] + [ str ( x ) for x in list ( save_var . values ())] cursor . executemany ( 'INSERT INTO Page_' + page + ' VALUES ' + '(' + ',' . join ([ '?' ] * ( keylen + 3 )) + ')' , ( vals ,)) con . commit () con . close ()","title":"Returns"},{"location":"code/#Code.sqltools.saveState","text":"Saves dictionary into a specified table in the database associated with the registered token. Creates the table on the first save. Table head is build from the save_var keys. Adds date and time stamps when savong data.","title":"saveState()"},{"location":"code/#Code.sqltools.saveState--parameters","text":"table: name of the table data is to be saved in type: str save_var: Dictionary of variables to be saved type: dict overwrite: optional (default: True), overwrites table if True, append data if False type: bool","title":"Parameters"},{"location":"code/#Code.sqltools.saveState--returns","text":"st.write: Source code in Code/sqltools.py def saveState ( table , save_var , overwrite = True ): ''' Saves dictionary into a specified table in the database associated with the registered token. Creates the table on the first save. Table head is build from the save_var keys. Adds date and time stamps when savong data. Parameters ---------- table: name of the table data is to be saved in type: str save_var: Dictionary of variables to be saved type: dict overwrite: optional (default: True), overwrites table if True, append data if False type: bool Returns ------- st.write: ''' if loginState (): # get active token token = activeToken () else : token = 'admin' #delete time/day token save_var . pop ( 'date' , None ) save_var . pop ( 'time' , None ) # create sql connection con = sqlite3 . connect ( 'registry/' + token + '.db' ) cursor = con . cursor () # check if table exists, create if it doesn't cursor . execute ( \"SELECT count(name) FROM sqlite_master WHERE type='table' AND name='\" + table + \"'\" ) if cursor . fetchone ()[ 0 ] == 1 : pass else : table_keys_start = '(date text, time text,' table_keys_end = ')' table_keys_mid = '' for k in list ( save_var . keys ()): table_keys_mid = table_keys_mid + str ( k ) + ' blob,' table_keys_mid = table_keys_mid [ 0 : - 1 ] table_keys = table_keys_start + table_keys_mid + table_keys_end cursor . execute ( \"CREATE TABLE \" + table + \" \" + table_keys ) con . commit () # delete table if overwrite == True if overwrite == True : con . execute ( 'DELETE FROM ' + str ( table )) else : pass # write date into table cursor . execute ( \"SELECT count(name) FROM sqlite_master WHERE type='table' AND name='\" + table + \"'\" ) day = str ( datetime . date . today ()) time = str ( datetime . datetime . now () . time ()) keylen = len ( list ( save_var . keys ())) vals = [ day , time ] + [ str ( x ) for x in list ( save_var . values ())] cursor . executemany ( 'INSERT INTO ' + table + ' VALUES ' + '(' + ',' . join ([ '?' ] * ( keylen + 2 )) + ')' , ( vals ,)) con . commit () con . close ()","title":"Returns"},{"location":"code/#Code.sqltools.userAdmin","text":"Creates necessary folder structure for logging in and saving data (registry folder) Creates ./registry/tokens.yaml Creates .registry/user.db Updates user.db according to the token.yml","title":"userAdmin()"},{"location":"code/#Code.sqltools.userAdmin--parameters","text":"tokenlist: of no token.yml exists, listelements define the first tokens in yaml and db type: list Source code in Code/sqltools.py def userAdmin ( tokenlist = [ 'admin' ]): ''' Creates necessary folder structure for logging in and saving data (registry folder) Creates ./registry/tokens.yaml Creates .registry/user.db Updates user.db according to the token.yml Parameters ---------- tokenlist: of no token.yml exists, listelements define the first tokens in yaml and db type: list ''' # create registry folder if os . path . isdir ( './registry' ): pass else : os . mkdir ( './registry' ) # creates token yaml file if os . path . isfile ( './registry/token.yml' ): pass else : with open ( './registry/token.yml' , 'w+' ) as y : yaml . dump ( tokenlist , y ) # setup SQL-connection con = sqlite3 . connect ( './registry/user.db' ) cursor = con . cursor () # create users table in sql database, update tokens cursor . execute ( \"SELECT count(name) FROM sqlite_master WHERE type='table' AND name='users'\" ) if cursor . fetchone ()[ 0 ] == 1 : with open ( './registry/token.yml' ) as tok : tokens = yaml . load ( tok , Loader = yaml . FullLoader ) active_tokens = [ x [ 0 ] for x in cursor . execute ( 'SELECT * FROM users' )] missing_tokens = [ x for x in tokens if x not in active_tokens ] for tok in missing_tokens : cursor . execute ( \"INSERT INTO users VALUES ('\" + tok + \"',' ')\" ) con . commit () else : cursor . execute ( \"CREATE TABLE users (token text, sessionID text)\" ) for token in tokenlist : cursor . execute ( \"INSERT INTO users VALUES ('\" + str ( token ) + \"',' ')\" ) con . commit () #close SQL connection con . close ()","title":"Parameters"},{"location":"collections/","text":"Text collections Textcollections (z.B. Euler Opera Omnia, Kepler Gesammelte Werke) collection path: /Volumes/openrepo/sources/eulerOO/ textcollection_eulerOO.json Textworks (z.B. einzelne Werke, aber auch Teile z.B. Kapitel, Aufs\u00e4tze)","title":"Text collections"},{"location":"collections/#text-collections","text":"Textcollections (z.B. Euler Opera Omnia, Kepler Gesammelte Werke) collection path: /Volumes/openrepo/sources/eulerOO/ textcollection_eulerOO.json Textworks (z.B. einzelne Werke, aber auch Teile z.B. Kapitel, Aufs\u00e4tze)","title":"Text collections"},{"location":"frontend/","text":"","title":"Frontend"},{"location":"libraries/","text":"Libraries pandas > 1.3 (string type) streamlit tree, networks networkx graphics tabulate graphicviz dictionaries yaml abdicts","title":"Libraries"},{"location":"libraries/#libraries","text":"pandas > 1.3 (string type) streamlit tree, networks networkx graphics tabulate graphicviz dictionaries yaml abdicts","title":"Libraries"},{"location":"panes/","text":"","title":"Panes"}]}